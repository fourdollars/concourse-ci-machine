#!/usr/bin/env python3
# Copyright 2026 Canonical Ltd.
# See LICENSE file for licensing details.

"""
Storage Coordinator Module for Shared Storage Feature

This module provides coordination mechanisms for shared storage across multiple
Concourse CI Juju charm units, enabling efficient binary sharing and reducing
disk space usage from N×binary size to ~1.15×.

Key Components:
- SharedStorage: Represents the shared filesystem mounted across all units
- LockCoordinator: Manages exclusive locks for binary downloads using fcntl
- UpgradeState: Tracks upgrade coordination state via peer relation data
- WorkerDirectory: Per-unit isolated state on shared storage
- ServiceManager: Manages systemd service lifecycle during upgrades

Design Principles:
- File-based locking (POSIX fcntl) for simplicity
- Web/leader-only downloads with exclusive locks
- Workers poll for existing binaries (no downloads)
- Per-unit worker directories for isolation
- Backward compatible with non-shared deployments

Feature: 001-shared-storage
Author: Generated by /speckit.implement
"""

import fcntl
import json
import logging
import os
import subprocess
import time
from contextlib import contextmanager
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Iterator, Literal, Optional

logger = logging.getLogger(__name__)


# ============================================================================
# Exception Hierarchy
# ============================================================================


class SharedStorageError(Exception):
    """Base exception for shared storage operations."""
    pass


class StorageNotMountedError(SharedStorageError):
    """Shared storage volume not mounted."""
    pass


class LockAcquireError(SharedStorageError):
    """Failed to acquire exclusive lock."""
    pass


class StaleLockError(SharedStorageError):
    """Stale lock detected and cleaned."""
    pass


class ServiceManagementError(SharedStorageError):
    """Failed to manage systemd service."""
    pass


class UpgradeTimeoutError(SharedStorageError):
    """Upgrade coordination timeout."""
    pass


# ============================================================================
# Core Data Classes
# ============================================================================


@dataclass
class SharedStorage:
    """Shared storage volume configuration and state.
    
    Represents the shared filesystem mounted across all Concourse CI units,
    enabling efficient binary sharing and reducing disk space usage.
    
    Attributes:
        volume_path: Mount point for shared storage (e.g., /var/lib/concourse)
        filesystem_id: Unique filesystem identifier for validation
        installed_version: Current installed Concourse version (from marker file)
        bin_directory: Path to shared Concourse binaries
        keys_directory: Path to shared TSA keys
        lock_file_path: Path to .install.lock file for download coordination
    
    Raises:
        StorageNotMountedError: If volume_path doesn't exist or isn't accessible
    """
    
    volume_path: Path
    filesystem_id: str
    installed_version: Optional[str] = None
    bin_directory: Optional[Path] = None
    keys_directory: Optional[Path] = None
    lock_file_path: Optional[Path] = None
    
    def __post_init__(self):
        """Validate paths exist and are accessible."""
        if not self.volume_path.exists():
            raise StorageNotMountedError(f"Volume not mounted: {self.volume_path}")
        
        # Set default subdirectories if not provided
        if self.bin_directory is None:
            self.bin_directory = self.volume_path / "bin"
        if self.keys_directory is None:
            self.keys_directory = self.volume_path / "keys"
        if self.lock_file_path is None:
            self.lock_file_path = self.volume_path / ".install.lock"
        
        # Ensure subdirectories exist
        self.bin_directory.mkdir(parents=True, exist_ok=True)
        self.keys_directory.mkdir(parents=True, exist_ok=True)
        
        # Read installed version if marker exists
        if self.installed_version is None:
            self.installed_version = self.read_installed_version()
    
    @property
    def version_marker_path(self) -> Path:
        """Path to .installed_version marker file."""
        return self.volume_path / ".installed_version"
    
    @property
    def progress_marker_path(self) -> Path:
        """Path to .download_in_progress marker file."""
        return self.volume_path / ".download_in_progress"
    
    def read_installed_version(self) -> Optional[str]:
        """Read installed version from marker file.
        
        Returns:
            Version string if marker exists, None otherwise
        """
        if not self.version_marker_path.exists():
            return None
        try:
            return self.version_marker_path.read_text().strip()
        except Exception as e:
            logger.warning(f"Failed to read installed version: {e}")
            return None
    
    def write_installed_version(self, version: str) -> None:
        """Write installed version to marker file (web/leader only).
        
        Args:
            version: Version string to write (e.g., "7.14.3")
        
        Note:
            This should only be called by web/leader units after
            successful binary download.
        """
        self.version_marker_path.write_text(version)
        self.installed_version = version
        logger.info(f"Updated installed version marker to {version}")


@dataclass
class LockCoordinator:
    """Coordinates download locks via fcntl.
    
    Manages exclusive file locks for binary downloads to ensure only
    web/leader units download binaries while workers wait and reuse.
    
    Attributes:
        lock_path: Path to .install.lock file for fcntl locking
        holder_unit: Unit name currently holding the lock
        acquired_at: Timestamp when lock was acquired (UTC)
        timeout_seconds: Stale lock threshold in seconds (default: 10 minutes)
    
    Example:
        coordinator = LockCoordinator(lock_path=Path("/var/lib/concourse/.install.lock"))
        with coordinator.acquire_exclusive():
            # Download binaries here - protected by exclusive lock
            download_concourse_binaries()
    """
    
    lock_path: Path
    holder_unit: Optional[str] = None
    acquired_at: Optional[datetime] = None
    timeout_seconds: int = 600  # 10 minutes
    
    @contextmanager
    def acquire_exclusive(self) -> Iterator[None]:
        """Acquire exclusive lock for binary download.
        
        Only web/leader should call this method. Uses fcntl.flock with
        LOCK_EX | LOCK_NB for non-blocking exclusive lock acquisition.
        
        Yields:
            None when lock successfully acquired
        
        Raises:
            LockAcquireError: If lock already held by another unit
            StaleLockError: If stale lock detected and cleaned
        
        Note:
            Lock is automatically released when context exits, even on exception.
        """
        # Check for stale locks first
        if self._is_stale():
            logger.warning("Stale download marker detected, cleaning up")
            self._clean_stale_markers()
            raise StaleLockError("Stale lock was detected and cleaned")
        
        # Ensure lock file parent directory exists
        self.lock_path.parent.mkdir(parents=True, exist_ok=True)
        
        lock_file = self.lock_path.open('w')
        try:
            # Non-blocking exclusive lock
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.holder_unit = os.environ.get('JUJU_UNIT_NAME', 'unknown')
            self.acquired_at = datetime.now(timezone.utc)
            logger.info(f"Lock acquired by {self.holder_unit} at {self.acquired_at}")
            yield
        except BlockingIOError:
            raise LockAcquireError(
                f"Download lock held by another unit. "
                f"Only web/leader should download binaries."
            )
        finally:
            # Release lock
            try:
                fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)
                lock_file.close()
            except Exception as e:
                logger.warning(f"Error releasing lock: {e}")
            self.holder_unit = None
            self.acquired_at = None
    
    def _is_stale(self) -> bool:
        """Check if progress marker is stale.
        
        Returns:
            True if .download_in_progress marker exists and is older
            than timeout_seconds, False otherwise
        """
        progress_marker = self.lock_path.parent / ".download_in_progress"
        if not progress_marker.exists():
            return False
        
        try:
            age_seconds = time.time() - progress_marker.stat().st_mtime
            is_stale = age_seconds > self.timeout_seconds
            if is_stale:
                logger.warning(
                    f"Progress marker is stale: {age_seconds:.0f}s old "
                    f"(threshold: {self.timeout_seconds}s)"
                )
            return is_stale
        except Exception as e:
            logger.error(f"Error checking progress marker age: {e}")
            return False
    
    def _clean_stale_markers(self) -> None:
        """Remove stale progress markers.
        
        Called when a stale .download_in_progress marker is detected,
        typically indicating a previous download failure or crash.
        """
        progress_marker = self.lock_path.parent / ".download_in_progress"
        try:
            if progress_marker.exists():
                progress_marker.unlink()
                logger.info("Cleaned stale progress marker")
        except Exception as e:
            logger.error(f"Failed to clean stale marker: {e}")


# TODO: T006 - Implement UpgradeState dataclass
# TODO: T007 - Implement WorkerDirectory dataclass
# TODO: T008 - Implement ServiceManager dataclass

# ============================================================================
# Interface Implementations (to be implemented in Phase 2)
# ============================================================================

# TODO: T009 - Implement IStorageCoordinator interface
# TODO: T010 - Implement IProgressTracker interface
# TODO: T011 - Implement IFilesystemValidator interface
# TODO: T012 - Implement IUpgradeCoordinator interface
# TODO: T013 - Implement IServiceManager interface
# TODO: T014 - Implement IRelationDataAccessor interface


# ============================================================================
# Module Initialization
# ============================================================================

__all__ = [
    # Exceptions
    'SharedStorageError',
    'StorageNotMountedError',
    'LockAcquireError',
    'StaleLockError',
    'ServiceManagementError',
    'UpgradeTimeoutError',
    # Data classes (to be added)
    # 'SharedStorage',
    # 'LockCoordinator',
    # 'UpgradeState',
    # 'WorkerDirectory',
    # 'ServiceManager',
]
